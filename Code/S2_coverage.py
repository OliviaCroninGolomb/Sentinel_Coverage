# -*- coding: utf-8 -*-
"""One_Run_S2_Coverage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DQdnIoe9zZ36GSOwFTQhhT43Bazm-nWM
"""

import ee
import geemap
import pandas as pd

# Trigger the authentication flow.
ee.Authenticate()

# Initialize the library.
ee.Initialize(project='ee-ocroningolomb')
#ee.Initialize(project='ee-s2aggregation')

"""# User Defined Variables"""

# Define filename and target spacecraft
targetS2 = 'Sentinel-2A' # User defined: Either 'Sentinel-2A', 'Sentinel-2B', or 'Sentinel-2AB'

if targetS2 == 'Sentinel-2A':
  satellite = 's2a'
elif targetS2 == 'Sentinel-2B':
  satellite = 's2b'
elif targetS2 == "Sentinel-2AB":
  satellite = 's2ab'
else:
  print('Target Satellite Not Properly Defined')

# Define output filepath
outputFilepath = 'S2A_Coverage' # User defined: Change to desired GDrive folder name

month = 'January' # User defined: Capitalized month

#Subset monthly ids
df = pd.DataFrame({"January": ["2023", "2023", "01", "02"],
                   "February": ["2023", "2023", "02", "03"],
                   "March": ["2023", "2023", "03", "04"],
                   "April": ["2023", "2023", "04", "05"],
                   "May": ["2023", "2023", "05", "06"],
                   "June": ["2023", "2023", "06", "07"],
                   "July": ["2023", "2023", "07", "08"],
                   "August": ["2023", "2023", "08", "09"],
                   "September": ["2023", "2023", "09", "10"],
                   "October": ["2023", "2023", "10", "11"],
                   "November": ["2023", "2023", "11", "12"],
                   "December": ["2023", "2024", "12", "01"]})

df = df.transpose()
df.columns =['startYear', 'endYear', "startMonth", "endMonth"]
df = df.transpose()

month_df = df[month]

startYear = month_df.iloc[0]
endYear = month_df.iloc[1]
startMonth = month_df.iloc[2]
endMonth = month_df.iloc[3]

df.head()

"""# Import and map area of interest"""

# Read in no Snow assets
#noSnow = ee.FeatureCollection('projects/ee-s2aggregation/assets/S2_noSnowIce/noSnow_' + assetID)
noSnow = ee.FeatureCollection('projects/ee-ocroningolomb/assets/noSnowIce/2023_' + startMonth + '_snowice')

#Read in resolable lakes assets
#resolvableLakes = ee.FeatureCollection('projects/ee-s2aggregation/assets/S3_ResolvableLakes')
resolvableLakes = ee.FeatureCollection('projects/ee-ocroningolomb/assets/S3_Lakes/S3_Resolvable_Lakes')

#Map resolvable lakes layer
#Map = geemap.Map()
#Map.addLayer(resolvableLakes, {"color": "blue"}, "Resolvable Lakes", shown=True)
#Map.addLayerControl()
#Map.setCenter(-96, 32, 5)
#Map

#Map no snow/ice layer
#Map = geemap.Map()
#Map.addLayer(noSnow, {"color": "red"}, month + " No Snow/Ice Area", shown=True, opacity=1)
#Map.addLayerControl()
#Map.setCenter(-96, 32, 4)
#Map

"""# Masking clouds and cloud shadows using s2Cloudless
### https://developers.google.com/earth-engine/tutorials/community/sentinel-2-s2cloudless
"""

# Define collection filter and cloud mask parameters of S2Cloudless (numbers used were those given in the tutorial)
AOI = noSnow
START_DATE = startYear + '-' + startMonth + '-01' #Inclusive
END_DATE = endYear + '-' + endMonth + '-01' #Exclusive
CLOUD_FILTER = 60 # Maximum image cloud cover percent allowed in image collection
CLD_PRB_THRESH = 50 # Cloud probability (%); values greater than are considered cloud
NIR_DRK_THRESH = 0.15 # Near-infrared reflectance; values less than are considered potential cloud shadow
CLD_PRJ_DIST = 1 # Maximum distance (km) to search for cloud shadows from cloud edges
BUFFER = 50 # Distance (m) to dilate the edge of cloud-identified objects

#Build a Sentinel-2 collection
def get_s2_sr_cld_col(AOI, START_DATE, END_DATE):

    # Import and filter S2 SR.
    if targetS2 != "Sentinel-2AB": # Filter by spacecraft name (S2A or S2B)
      s2_sr_col = (ee.ImageCollection('COPERNICUS/S2_SR')
          .filterBounds(AOI)
          .filterDate(START_DATE, END_DATE)
          .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', CLOUD_FILTER))
          .filter(ee.Filter.eq('SPACECRAFT_NAME', targetS2)))

    elif targetS2 == "Sentinel-2AB": # Use combined S2A and S2B collection
      s2_sr_col = (ee.ImageCollection('COPERNICUS/S2_SR')
        .filterBounds(AOI)
        .filterDate(START_DATE, END_DATE)
        .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', CLOUD_FILTER)))

    # Import and filter s2cloudless.
    s2_cloudless_col = (ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY')
        .filterBounds(AOI)
        .filterDate(START_DATE, END_DATE))

    # Join the filtered s2cloudless collection to the SR collection by the 'system:index' property.
    return ee.ImageCollection(ee.Join.saveFirst('s2cloudless').apply(**{
        'primary': s2_sr_col,
        'secondary': s2_cloudless_col,
        'condition': ee.Filter.equals(**{
            'leftField': 'system:index',
            'rightField': 'system:index'
        })
    }))

# Cloud components
def add_cloud_bands(img):
    # Get s2cloudless image, subset the probability band.
    cld_prb = ee.Image(img.get('s2cloudless')).select('probability')

    # Condition s2cloudless by the probability threshold value.
    is_cloud = cld_prb.gt(CLD_PRB_THRESH).rename('clouds')

    # Add the cloud probability layer and cloud mask as image bands.
    return img.addBands(ee.Image([cld_prb, is_cloud]))

# Cloud shadow components
def add_shadow_bands(img):
    # Identify water pixels from the SCL band.
    not_water = img.select('SCL').neq(6)

    # Identify dark NIR pixels that are not water (potential cloud shadow pixels).
    SR_BAND_SCALE = 1e4
    dark_pixels = img.select('B8').lt(NIR_DRK_THRESH*SR_BAND_SCALE).multiply(not_water).rename('dark_pixels')

    # Determine the direction to project cloud shadow from clouds (assumes UTM projection).
    shadow_azimuth = ee.Number(90).subtract(ee.Number(img.get('MEAN_SOLAR_AZIMUTH_ANGLE')));

    # Project shadows from clouds for the distance specified by the CLD_PRJ_DIST input.
    cld_proj = (img.select('clouds').directionalDistanceTransform(shadow_azimuth, CLD_PRJ_DIST*10)
        .reproject(**{'crs': img.select(0).projection(), 'scale': 100})
        .select('distance')
        .mask()
        .rename('cloud_transform'))

    # Identify the intersection of dark pixels with cloud shadow projection.
    shadows = cld_proj.multiply(dark_pixels).rename('shadows')

    # Add dark pixels, cloud projection, and identified shadows as image bands.
    return img.addBands(ee.Image([dark_pixels, cld_proj, shadows]))

# Final cloud-shadow mask
def add_cld_shdw_mask(img):
    # Add cloud component bands.
    img_cloud = add_cloud_bands(img)

    # Add cloud shadow component bands.
    img_cloud_shadow = add_shadow_bands(img_cloud)

    # Combine cloud and shadow mask, set cloud and shadow as value 1, else 0.
    is_cld_shdw = img_cloud_shadow.select('clouds').add(img_cloud_shadow.select('shadows')).gt(0)

    # Remove small cloud-shadow patches and dilate remaining pixels by BUFFER input.
    # 20 m scale is for speed, and assumes clouds don't require 10 m precision.
    is_cld_shdw = (is_cld_shdw.focalMin(2).focalMax(BUFFER*2/20)
        .reproject(**{'crs': img.select([0]).projection(), 'scale': 20})
        .rename('cloudmask'))

    # Add the final cloud-shadow mask to the image.
    return img_cloud_shadow.addBands(is_cld_shdw)

# Define cloud mask application function
def apply_cld_shdw_mask(img):
    # Subset the cloudmask band and invert it so clouds/shadow are 0, else 1.
    not_cld_shdw = img.select('cloudmask').Not()

    # Subset reflectance bands and update their masks, return the result.
    return img.select('B5').updateMask(not_cld_shdw)

# Process the collection
s2_sr_cld_col = get_s2_sr_cld_col(AOI, START_DATE, END_DATE)

#s2_sr_median = (s2_sr_cld_col.map(add_cld_shdw_mask)
#                             .map(apply_cld_shdw_mask)
#                             .median())

#s2_sr_max = (s2_sr_cld_col.map(add_cld_shdw_mask)
#                             .map(apply_cld_shdw_mask)
#                             .max())

s2_sr_mean = (s2_sr_cld_col.map(add_cld_shdw_mask)
                             .map(apply_cld_shdw_mask)
                             .mean())

# Display the cloud-free composite of the AOI (it takes a while to load, so don't worry if nothing comes up for the fist couple minutes)
#image_viz_params = {
#    'bands': ['B5'],
#    'min': 0,
#    'max': 3000,
#}

#Map = geemap.Map()
#Map.addLayer(s2_sr_median,image_viz_params, "Cloud & cloud shadow masked median month B5 raster from " + targetS2)
#Map.addLayer(resolvableLakes, {"color": "blue"}, "Resolvable Lakes", shown=True)
#Map.addLayer(noSnow, {"color": "red"}, "No Snow/Ice Area", shown=True, opacity=0.5)
#Map.addLayerControl()
#Map.setCenter(-96, 32, 8)
#Map

#Another cloudmask option, but s2cloudless is recommended

#def se2mask(image):
#    quality_band = image.select('QA60')

    # using the bit mask for clouds and cirrus clouds respectively
#    cloudmask = 1 << 10
#    cirrusmask = 1 << 11

    # we only want clear skies
 #   mask = quality_band.bitwiseAnd(cloudmask).eq(0) and (quality_band.bitwiseAnd(cirrusmask).eq(0))

    # we'll divide by 10000 to make interpreting the reflectance values easier
 #   return image.updateMask(mask)

#se2 = ee.ImageCollection('COPERNICUS/S2').filterDate("2023-01-01","2023-02-01").filter(ee.Filter.eq('SPACECRAFT_NAME', targetS2)).filterBounds(noSnow).filter(
#    ee.Filter.lt("CLOUDY_PIXEL_PERCENTAGE",10)).map(se2mask).select('B[5]').median()

"""# Clip cloudmasked median raster to AOI"""

# Clip median and max raster to resolveable lakes that are snow and ice free
#lakeClipMedian = s2_sr_median.select(0).clipToCollection(resolvableLakes);
#lakeClipMax = s2_sr_max.select(0).clipToCollection(resolvableLakes);
lakeClipMean = s2_sr_mean.select(0).clipToCollection(resolvableLakes);

#snowClip = lakeClip.select(0).clipToCollection(noSnow);

#Map = geemap.Map()
#Map.addLayer(noSnow, {"color": "red"}, "No Snow/Ice Area", shown=True, opacity=0.3)
#Map.addLayer(resolvableLakes, {}, "Resolvable Lakes", shown = False)

#vis_params = {
#    'color': '000000',
#    'width': 1,
#    'lineType': 'solid',
#    'fillColor': '00000000',
#}

#Map.addLayer(resolvableLakes.style(**vis_params), {}, "Resolvable Lakes")
#Map.add_layer(snowClip, image_viz_params, 'AOI clip', shown = True)
#Map.addLayerControl()
#Map.set_center(-96, 32, 10)
#Map

"""# Generate mean and max zonal stats on clipped median raster"""

#statsDF = lakeClip.reduceRegions(
#  reducer= ee.Reducer.mean().combine(
#    reducer2= ee.Reducer.max(),
#    sharedInputs= True
#  ),
#  collection=noSnow,
#  scale= 20,
#);

#statsMedian = lakeClipMedian.reduceRegions(**{
#  'collection': noSnow,
#  'reducer': ee.Reducer.mean().setOutputs(["meanMedian"]),
#  'scale': 20,
#})

#statsMax = lakeClipMax.reduceRegions(**{
#  'collection': noSnow,
#  'reducer': ee.Reducer.mean().setOutputs(["meanMax"]),
#  'scale': 20,
#})

statsMean = lakeClipMean.reduceRegions(**{
  'collection': noSnow,
  'reducer': ee.Reducer.mean().setOutputs(["meanMean"]),
  'scale': 20,
})

"""# Export data to GDrive"""

#taskMedian = ee.batch.Export.table.toDrive(
#  collection=statsMedian,
#  description=month + '_' + satellite + '_median',
#  fileFormat='CSV',
#  selectors=['meanMedian'],
#  folder=outputFilepath,
#);
#taskMedian.start()

#taskMax = ee.batch.Export.table.toDrive(
#  collection=statsMax,
#  description=month + '_' + satellite + '_max',
#  fileFormat='CSV',
#  selectors=['meanMax'],
#  folder=outputFilepath,
#);
#taskMax.start()

taskMean = ee.batch.Export.table.toDrive(
  collection=statsMean,
  description=month + '_' + satellite + '_mean',
  fileFormat='CSV',
  selectors=['meanMean'],
  folder=outputFilepath,
);
taskMean.start()